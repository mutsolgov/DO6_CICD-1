# Basic CI/CD

### Part 1. Настройка **gitlab-runner**


##### Поднимим виртуальную машину *Ubuntu Server 22.04 LTS*.
![](src/screenshots/e-1.png)

##### Скачаем и установим на виртуальную машину **gitlab-runner**.
![](src/screenshots/e-2.png)

##### Запустим **gitlab-runner** и зарегистрируем его для использования в текущем проекте (*DO6_CICD*).
![](src/screenshots/e-3.png)

### Part 2. Сборка


#### Напишим этап для **CI** по сборке приложений из проекта *C2_SimpleBashUtils*.
#### Для этого скопируем в папку `src` папки `cat` и `grep` из проекта `C2_SimpleBashUtils`:
![](src/screenshots/e-4.png)

##### В файле _.gitlab-ci.yml_ добавим этап запуска сборки через мейк файл из проекта _C2_.

##### Файлы, полученные после сборки (артефакты), сохраним в произвольную директорию со сроком хранения 30 дней.
![](src/screenshots/e-5.png)

##### Проверим сборку проекта
![](src/screenshots/e-6.png)

### Part 3. Тест кодстайла


#### Напишим этап для **CI**, который запускает скрипт кодстайла (*clang-format*).

##### Если кодстайл не прошел, то «зафейлим» пайплайн с помощью флага --Werror.
![](src/screenshots/e-7.png)

##### В пайплайне отобразим вывод утилиты *clang-format* с зафейлинным пайплайном.
![](src/screenshots/e-8.png)

#### Отобразим вывод утилиты *clang-format* с пройденным пайплайном.
![](src/screenshots/e-9.png)


### Part 4. Интеграционные тесты


#### Напишим этап для **CI**, который запускает наши интеграционные тесты из того же проекта.
![](src/screenshots/e-10.png)

##### Если тесты не прошли, то «зафейлим» пайплайн.
![](src/screenshots/e-11.png)


##### В пайплайне отобразим вывод, что интеграционные тесты успешно прошли / провалились.
![](src/screenshots/e-12.png)


### Part 5. Этап деплоя


#### Напишим этап для **CD**, который «разворачивает» проект на другой виртуальной машине.

##### Поднимим вторую виртуальную машину.
![](src/screenshots/e-13.png)

##### Соединим между собой виртуальные машины, для этого внесем изменения в сетевые настройки
![](src/screenshots/e-14.png)
![](src/screenshots/e-15.png)

##### Переключимся на первой виртиальной машине где у нас установлен `gitlab-runner` на пользователя `gitlab-runner`, и выполним генерацию пары ключей SSH с использованием алгоритма RSA командой `ssh-keygen -t rsa -b 2048` для настройки доступа к второму серверу с безпарольным доступом по SSH: 
![](src/screenshots/e-16.png)

##### Командой `ssh-copy-id server@10.10.0.1` скопируем публичный SSH-ключ на удалённый сервер, чтобы настроить безпарольный доступ по SSH:
![](src/screenshots/e-17.png)

##### На второй машине командой `sudo chmod -R 777 /usr/local/bin` предоставим доступ к файлам и папкам для чтения, изменения и исполнения файлов.
![](src/screenshots/e-18.png)

##### Проверим соединения между машинами без ввода пароля командой `ssh server@10.10.0.1`:
![](src/screenshots/e-19.png)




##### Запусти этот этап вручную при условии, что все предыдущие этапы прошли успешно.

##### Напишим bash-скрипт, который при помощи **ssh** и **scp** копирует файлы, полученные после сборки (артефакты), в директорию */usr/local/bin* второй виртуальной машины.
![](src/screenshots/e-20.png)
- Объясним по скрипту, как происходит перенос.
  разберем команду `ssh-keyscan -H 10.10.0.1 >> ~/.ssh/known_hosts`:

`ssh-keyscan`: утилита, которая собирает открытые SSH-ключи с указанного сервера.
`-H`: опция, которая выводит хосты в зашифрованном виде (защищает от DNS spoofing).
`10.10.0.1`: IP-адрес удалённого сервера, с которого нужно получить SSH-ключ.
`>> ~/.ssh/known_hosts`: команда добавляет (двойная стрелка >>) полученные SSH-ключи в файл `~/.ssh/known_hosts`. Этот файл используется для хранения известных ключей удалённых серверов, чтобы избежать запроса на подтверждение доверия при первом подключении по SSH.

разберем команду `scp artifacts/s21_cat artifacts/s21_grep server@10.10.0.1:/usr/local/bin`:

`scp`: утилита для безопасной копировки файлов между локальной и удалённой машинами через SSH.
`artifacts/s21_cat и artifacts/s21_grep`: локальные файлы, которые нужно скопировать (в данном случае это бинарные файлы, собранные в процессе сборки проекта).
`server@10.10.0.1:/usr/local/bin`: путь на удалённой машине, куда файлы будут скопированы.

разберем команду `ssh server@10.10.0.1 "chmod +x /usr/local/bin/s21_cat /usr/local/bin/s21_grep"`:

`ssh server@10.10.0.1`: команда для выполнения SSH-подключения к серверу с IP 10.10.0.1 от имени пользователя server.
`"chmod +x /usr/local/bin/s21_cat /usr/local/bin/s21_grep"`: команда, которая будет выполнена на удалённой машине. Она изменяет права доступа к файлам s21_cat и s21_grep, делая их исполняемыми (добавляет флаг +x).

##### В файле _gitlab-ci.yml_ добавим этап запуска написанного скрипта.
![](src/screenshots/e-21.png)

##### Проверим что в gitlabe все собирается:
![](src/screenshots/e-22.png)
![](src/screenshots/e-23.png)

##### Проверим что в результате мы получили готовые к работе приложения из проекта *C2_SimpleBashUtils* (s21_cat и s21_grep) на второй виртуальной машине.
![](src/screenshots/e-24.png)


##### Сохраним дампы образов виртуальных машин.
![](src/screenshots/e-25.png)
![](src/screenshots/e-26.png)


### Part 6. Дополнительно. Уведомления


##### Создадим бота в нашем telegram:
![](src/screenshots/e-30.png)


##### Настроем уведомления об успешном/неуспешном выполнении пайплайна через бота в *Telegram*.

##### Для этого сначала напишем скрипт:
![](src/screenshots/e-27.png)

##### Затем в файле _gitlab-ci.yml_ пропишем чтобы наш скрипт запускался после сборки
![](src/screenshots/e-28.png)

##### Проверяем что в нашем telegram выводятся уведомления:
![](src/screenshots/e-29.png)